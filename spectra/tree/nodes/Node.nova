package "spectra/tree/nodes"

import "spectra/Spectra"
import "spectra/InvalidParseException"
import "spectra/SyntaxErrorException"
import "spectra/error/UnimplementedOperationException"
import "spectra/tree/nodes/annotations/Annotatable"
import "spectra/tree/nodes/annotations/Annotation"
import "spectra/tree/nodes/exceptionhandling/Try"
import "spectra/util/Location"
import "spectra/error/UnimplementedOperationException"
import "spectra/tree/nodes/functions/FunctionDeclaration"
import "spectra/tree/nodes/functions/FunctionCall"
import "spectra/tree/nodes/functions/Instantiation"
import "spectra/tree/nodes/functions/closures/LambdaExpression"
import "spectra/tree/nodes/variables/VariableDeclaration"

import "nova/datastruct/Bounds"

/// Class that is the parent of all Nodes on the Tree. Keeps the basic
/// information of where the statement was in the source, and where it was
/// output in the destination file.
/// 
/// author:  Braden Steffaniak
/// since:   v0.1 Jan 5, 2014 at 9:00:11 PM
/// version: v0.2.41 Dec 17, 2014 at 7:48:17 PM
[AutoFinal]
class Node implements Annotatable {
    visible var Location location
    
    visible var Annotation[] annotations
    
    public var Node parent
    
    visible String locationInfo {
        get {
            var info = ""
            
            if (parentFile) {
                info += "in file #parentFile.name"
            }
            if (location) {
                info += (info.count > 0 ? " " : "") + "on line number #location.lineNumber at offset #location.offset"
            }
            
            return info
        }
        
        no set
    }
    
    public String nodeType {
        get {
            let name = this.class.name
            
            return name
        }
        
        no set
    }
    
    
    /// Get whether or not the specified Node is being decoded at
    /// the current moment.
    /// 
    /// return: Whether or not the specified Node is being decoded at
    ///         the current moment.
    visible Bool isDecoding => false
    visible Bool isValid => parent != null
    visible Bool isUserMade => true
    visible Bool isWithinStaticContext => !parentFunction || !parentFunction.isInstance
    visible Bool isWithinExternalContext => parent?.isWithinExternalContext
    
    visible Program program => parent?.program
    
    visible Byte phase => program.tree.phase
    
    visible Instantiation parentInstantiation => parent?.parentInstantiation
    visible LambdaExpression parentLambda => parent?.parentLambda
    
    visible NovaFile parentFile => parent?.parentFile
    visible Bool isWithinFile => parentFile != null
    
    visible FunctionCall parentFunctionCall => parent?.parentFunctionCall
    
    visible FunctionDeclaration parentFunction => parent?.parentFunction
    visible Bool isWithinFunction => parentFunction != null
    
    visible Try parentTry => parent?.parentTry
    visible Bool isWithinTry => parentTry != null
    
    visible ClassDeclaration parentClass => parent?.parentClass
    visible Bool isWithinClass => parentClass != null
    
    visible Scope parentScope => parentWithScope.scope
    visible Bool isWithinScope => parentScope != null
    
    visible Node parentWithScope {
        get {
            if (!parent) return null
            
            return parent.containsScope ? parent : parent.parentWithScope
        }
        
        no set
    }
    
    public Node scopeConsumer => this
    
    public var Scope scope {
        get {
            let consumer = scopeConsumer
            
            return consumer && consumer != this ? consumer.scope : null
        }
        
        set {
            let consumer = scopeConsumer
            
            if (consumer && consumer != this) {
                consumer.setScope(value)
            }
        }
    }
    
    setScope(Scope s) => this.scope = s
    
    visible Bool containsScope => scope != null
    
    visible Node next => getAdjacentNode(1)
    visible Node previous => getAdjacentNode(-1)
    
    visible Int index {
    	get { parentScope.children.indexOf(this) }
        set { parentScope.children.swap(index, value) }
    }
    
    public getAdjacentNode(Int offset) -> Node => null {
        if (parent) {
            Int index = this.index + offset
            
            if (index >= 0 && index < parentScope.children.count) {
                return (Node)parentScope.children[index]
            }
        }
    }
    
    /// Create a new Node. Initializes the data.
    /// 
    /// parent:   The Node to act as the parent temporarily.
    /// location: The location of the Node in the source file.
    public construct(Node parent = null, Location location = Location.INVALID) {
        this.parent = parent
        this.location = location
    }
    
    [Override]
    public addAnnotation(Annotation annotation) {
        annotations = annotations ?: new Annotation[]
        
        annotations.add(annotation)
        
        annotation.parent = this
    }
    
    /// Detach the specified node from its parent.
    public detach() {
        if (isDecoding) return
        
        detach(parent)
    }
    
    /// Detach the specified Node from the given Node.
    ///
    /// fromNode: The Node to detach the specified Node from.
    private detach(Node fromNode) {
    	let p = parent
    	
        parent = null
        
        p.onChildDetached(this)
        onRemoved(fromNode)
    }
    
    public addChild(Node child) {
        child.parent = this
        
        child?.onAdded(this)
    }
    
    public onAdded(Node parent) {}
    public onRemoved(Node from) {}
    
    public onAfterDecoded() => true
    public onNextStatementDecoded(Node next) => true
    public onStackPopped() {}
    public followedByScope(Bool scope) {}
    public onChildReplaced(Node old, Node replacement) {}
    public onReplaced(Node parent, Node replacement) {}
    public onChildDetached(Node child) {}
    
    /// Validate the node to make last minute changes or error checking.
    /// 
    /// phase:  The phase that the node is being validated in.
    /// return: The Node to continue the validation off of.
    public validate(Int phase) -> ValidationResult {
        return annotations?.reverse().firstNonNull({
            ValidationResult result = _.validate(phase)
            
            return result.skipValidation ? result : null
        }) ?: new ValidationResult(this)
        
        /*return annotations?.reverse()
            .firstNonNull({ (let result = _.validate(phase)).skipValidation ? result : null }) ?:
            new ValidationResult(this)*/
    }
    
    public findVariableDeclaration(String name, Bool searchAncestors = true) -> VariableDeclaration {
        if (containsScope) {
            let declaration = scope.declarations.firstWhere({ _.name.equals(name) })
            
            if (declaration) {
                return declaration
            }
        }
        
        if (searchAncestors && parent) {
            return parent.findVariableDeclaration(name, searchAncestors)
        }
        
        return null
    }
    
    public parseStatement(String input, Node parent = null, Location location = Location.INVALID, Bool require = true) -> Node {
        return parentWithScope?.parseStatement(input, parent, location, require)
    }
    
    public generateTemporaryScopeNode() -> Node =>
        throw new UnimplementedOperationException("#this.class does not implement generateTemporaryScopeNode")
    
    public static strictParse(action()) {
        try {
            action()
        } catch all (InvalidParseException e) {
            Console.log(e)
        }
    }
    
    public static catchSyntaxErrors(action()) {
        try {
            action()
        } catch (SyntaxErrorException e) {
            Console.log(e)
        }
    }
    
    /// Return a new Node containing a copy of the values of the
    /// specified node, including clones of the children.
    /// 
    /// parent:        The Node to set as the parent.
    /// location:      The Location instance holding the information.
    /// cloneChildren: Whether or not to clone the children of the
    ///                Node as well.
    /// return:        A clone of the specified Node.
    public clone(Node parent = null, Location location = Location.INVALID, Bool cloneChildren = true) =>
        cloneTo(new Node(parent, location))
    
    public cloneTo(Node other) => other {
        other.parent = parent
        other.location = location
        other.annotations = annotations
    }
    
    public replace(Node toReplace, Node replacement) => false
    public validateTypes() => true
    
    public parsePlaceholders() =>
        scope ?
            scope.parsePlaceholders() :
            true
    
    public parsePlaceholderChildren(NodeList<PlaceholderValue> nodes) -> Bool =>
        scopeConsumer && scopeConsumer != this ?
            scopeConsumer.parsePlaceholderChildren(nodes) :
            nodes.children.all(child -> {
                if (scope) {
                    scope.addChild(child)
                    
                    return child.parsePlaceholders()
                }
                
                return false
            }, false)
    
    public writeAnnotationSeparator() => " "
    
    public writeAnnotations() =>
        annotations && annotations.count > 0 ?
            annotations.map({ _.toNova() }).join(" ") + writeAnnotationSeparator() :
            ""
    
    public toNova() -> String => writeAnnotations() + writeNova()
    
    public writeNova() => "{{#this.class}}"
    public toString() => toNova()
}