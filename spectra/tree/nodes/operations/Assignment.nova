package "spectra/tree/nodes/operations"

import "spectra/SyntaxMessage"
import "spectra/tree/nodes/Value"
import "spectra/tree/nodes/Node"
import "spectra/tree/nodes/Type"
import "spectra/tree/nodes/variables/LocalDeclaration"
import "spectra/tree/nodes/variables/Variable"
import "spectra/tree/nodes/variables/ImplicitDeclaration"
import "spectra/tree/nodes/variables/VariableDeclaration"
import "spectra/util/Location"

import "spectra/util/CompilerStringFunctions"

class Assignment extends Operation {
    public Value assigned <=> operands[0]
    public Value assignment <=> operands[1]
    
    public Node scopeConsumer => assignment.returnedNode
    
    visible Type type => assignment.returnedNode.type
    
    visible VariableDeclaration assignedDeclaration =>
        assigned.class.isOfType(VariableDeclaration) ?
            (VariableDeclaration)assigned :
            ((Variable)assigned).declaration
    
    /// Create a new Assignment node.
    /// 
    /// #exampleInputs
    /// 
    /// parent: The parent of the Assignment node.
    /// location: The location of the input text in the source file.
    public construct(Node parent = null, Location location = Location.INVALID) {
        super(parent, location)
        
        operands = new Value[2]
    }
    
    /// Parse the given input into a Assignment node. If the input cannot be parsed
    /// into a Assignment node, null is returned.
    /// 
    /// #exampleInputs:
    ///     Example inputs:
    ///      * 
    ///      * 
    ///      * 
    /// 
    /// input:    The input string to parse into a Assignment instance.
    /// parent:   The parent of the Assignment node.
    /// location: The location of the input text in the source file.
    /// require:  Whether or not to throw a syntax error if the input could not
    ///           be parsed.
    /// return:   The parsed Assignment node, if successful; null otherwise.
    public static parse(String input, Node parent = null, Location location = Location.INVALID, Bool require = true) -> Assignment => null {
        var assignmentIndex = input.findOperatorOnTopLevel('=')
        
        if (assignmentIndex > 0) {
            var node = new Assignment(parent, location)
            
            if (node.parseAssignedNode(findAssigned(input, assignmentIndex)) && node.parseAssignment(findAssignment(input, assignmentIndex))) {
                node.operators.add(new Operator(node, location, "="))
                
                if (node.assigned.class.isOfType(VariableDeclaration)) {
                    node.parentScope.declarations.add((VariableDeclaration)node.assigned)
                }
                
                ((Assignable)node.assigned).onAssigned(node.assignment)
                ((Assignable)node.assignment).onAssignedTo(node.assignedDeclaration)
                
                return node
            }
        }
    }
    
    public static findAssigned(String input, Int assignmentIndex) =>
        input.substring(end: assignmentIndex).trim()
    
    public static findAssignment(String input, Int assignmentIndex) =>
        input.substring(assignmentIndex + 1).trim()
    
    parseAssignedNode(String input) -> Bool {
        LocalDeclaration declaration = null
        
        until (declaration) {
            declaration = ImplicitDeclaration.parse(input, this, location, require: false)
            declaration = LocalDeclaration.parse(input, this, location, require: false)
        }
        
        if (declaration) {
            assigned = declaration
            
            return true
        } else {
            var value = Value.parse(input, this, location, require: false)
            
            if (value) {
                if (value.isAssignable) {
                    assigned = value
                    
                    return true
                } else {
                    SyntaxMessage.error("#value.nodeType '#input' is not assignable", value)
                }
            }
        }
        
        return false
    }
    
    parseAssignment(String input) =>
        (assignment = Value.parse(input, this, location)) != null
}