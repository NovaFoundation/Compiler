package "spectra/tree/nodes/functions"

import "spectra/SyntaxErrorException"
import "spectra/InvalidParseException"
import "spectra/util/Location"
import "spectra/tree/nodes/Node"
import "spectra/tree/nodes/ArrayType"
import "spectra/tree/nodes/Value"
import "spectra/tree/nodes/Type"
import "spectra/tree/nodes/variables/VariableDeclaration"

import "spectra/util/CompilerStringFunctions"

/// @Instantiation extension that represents 
///
/// author: Braden Steffaniak
/// since: 
/// version: 
class ArrayInstantiation extends Instantiation {
    visible Value[] dimensions = new Value[]
    
    visible ArrayType arrayType => (ArrayType)declaration.type
    
    /// Create a new ArrayInstantiation node.
    /// 
    /// #exampleInputs
    /// 
    /// parent:   The parent of the ArrayInstantiation node.
    /// location: The location of the input text in the source file.
    public construct(Node parent = null, Location location = Location.INVALID) {
        super(parent, location)
    }
    
    /// Parse the given input into a ArrayInstantiation node. If the input cannot be parsed
    /// into a ArrayInstantiation node, null is returned.
    /// 
    /// #exampleInputs:
    ///     Example inputs:
    ///      * 
    ///      * 
    ///      * 
    /// 
    /// input:    The input string to parse into a ArrayInstantiation instance.
    /// parent:   The parent of the ArrayInstantiation node.
    /// location: The location of the input text in the source file.
    /// require:  Whether or not to throw a syntax error if the input could not
    ///           be parsed.
    /// return:   The parsed ArrayInstantiation node, if successful; null otherwise.
    public static parse(String input, Node parent = null, Location location = Location.INVALID, Bool require = true) -> ArrayInstantiation => null {
        if (input.nextWord() == "new") {
            let node = new ArrayInstantiation(parent, location)
            
            let arrayString = input.substring("new".count + 1).trim()
            let arrayData = arrayString.getArrayAccesses()
            
            if (arrayData.item1) {
                let type = arrayString.substring(end: arrayData.item2[0]).trim()
                
                if (!node.parseType(type)) {
                    toss new InvalidParseException("Unable to parse array type '#type'", node)
                } else if (!node.parseDimensions(arrayData.item1)) {
                    toss new InvalidParseException("Unable to parse array dimensions '#arrayString.substring(arrayData.item2[0]).trim()'")
                } else {
                    node.declaration = new VariableDeclaration(parent, location)
                    node.declaration.name = type
                    node.declaration.type = ArrayType.parse(type + "[]".repeat(node.dimensions.count), node)
                    
                    if (!node.declaration.type) {
                        toss new InvalidParseException("Unable to parse array type '#type'", node)
                    } else {
                        return node
                    }
                }
            }
        }
    }
    
    parseDimension(String dimension) => true {
        if (dimension.count > 0) {
            let value = Value.parse(dimension, this)
            
            if (value) {
                dimensions.add(value)
            } else {
                return false
            }
        } else {
            dimensions.add(null)
        }
    }
    
    parseDimensions(String[] dimensions) =>
        dimensions.all(parseDimension, false)
    
    public writeDimensions() =>
        dimensions.count > 0 ?
            dimensions.map(d => { d ? "[#{d.toNova()}]" : "[]" }).join() :
            "[]"
    
    public writeNova() => "new #arrayType.type.name" + writeDimensions()
}