package "spectra/tree/nodes/variables"

import "spectra/tree/nodes/Node"
import "spectra/tree/nodes/Value"
import "spectra/tree/nodes/PlaceholderValue"
import "spectra/tree/nodes/functions/BodyFunction"
import "spectra/tree/nodes/operations/Assignable"
import "spectra/SyntaxErrorException"
import "spectra/util/Location"

import "spectra/util/CompilerStringFunctions"

class FieldDeclaration extends InstanceDeclaration implements Assignable {
    String[] extraDeclarations
    
    public Value initializationValue
    
    visible Value accessorValue
    
    visible Bool isTwoWayAccessor = false
    
    /// Create a new FieldDeclaration node.
    /// #exampleInputs
    /// 
    /// parent:   The parent of the FieldDeclaration node.
    /// location: The location of the input text in the source file.
    public construct(Node parent = null, Location location = Location.INVALID) {
        super(parent, location)
    }
    
    public generateTemporaryScopeNode() -> Node {
        return new BodyFunction(this)
    }
    
    public onAdded(Node to) {
        super.onAdded(to)
        
        if (extraDeclarations) {
            for (name in extraDeclarations) {
                let declaration = cloneTo(new FieldDeclaration(parent, location))
                declaration.name = name
                declaration.extraDeclarations = null
                
                to.addChild(declaration)
            }
        }
    }
    
    /// Parse the given input into a FieldDeclaration node. If the input cannot be parsed
    /// into a FieldDeclaration node, null is returned.
    /// 
    /// #exampleInputs:
    ///     Example inputs:
    ///      * 
    ///      * 
    ///      * 
    /// 
    /// input:    The input string to parse into a FieldDeclaration instance.
    /// parent:   The parent of the FieldDeclaration node.
    /// location: The location of the input text in the source file.
    /// require:  Whether or not to throw a syntax error if the input could not
    ///           be parsed.
    /// return:   The parsed FieldDeclaration node, if successful; null otherwise.
    public static parse(String input, Node parent = null, Location location = Location.INVALID, Bool require = true) -> FieldDeclaration => null {
        String initializationValue = null
        String accessorValue = null
        
        var twoWay = false
        
        var accessorIndex = findAccessorIndex(input)
        
        if (accessorIndex > 0) {
            var accessorOperator = input[accessorIndex] == '<' ? "<=>" : "=>"
            
            accessorValue = input.substring(accessorIndex + accessorOperator.count).trim()
            twoWay = accessorOperator == "<=>"
            input = input.substring(end: accessorIndex).trim()
        } else {
            var initializationValueIndex = input.indexOf('=')
            
            if (initializationValueIndex > 0) {
                initializationValue = input.substring(initializationValueIndex + 1).trim()
                input = input.substring(end: initializationValueIndex).trim()
            }
        }
        
        let extraDeclarationsIndex = findExtraDeclarationsIndex(input)
        var extraDeclarations = (String)null
        
        if (extraDeclarationsIndex > 0) {
            extraDeclarations = input.substring(extraDeclarationsIndex + 1).trim()
            input = input.substring(end: extraDeclarationsIndex).trim()
        }
        
        let declaration = InstanceDeclaration.parse(input, parent, location, require)
        
        if (declaration) {
            var node = new FieldDeclaration(parent, location)
            
            if (accessorValue) {
                node.accessorValue = PlaceholderValue.parse(accessorValue, node, location)
                node.isTwoWayAccessor = twoWay
            } else if (initializationValue) {
                node.initializationValue = PlaceholderValue.parse(initializationValue, node, location)
            } else if (extraDeclarations) {
                node.extraDeclarations = extraDeclarations.splitAtCommas()
            }
            
            return (FieldDeclaration)declaration.cloneTo(node)
        }
    }
    
    static findExtraDeclarationsIndex(String input) -> Int {
        var index = input.lastIndexOf(',')
        var last = input.count - 1
        
        while (index > 0) {
            if (!input.substring(index + 1, last).trim().isIdentifier) {
                return 0
            }
            
            last = index
            index = input.lastIndexOf(',', index - 2)
        }
        
        return last < input.count - 1 ? last : 0
    }
    
    static findAccessorIndex(String input, Int defaultReturnValue = -1) -> Int {
        var index = input.findOperatorOnTopLevel("=>")
        
        if (index < 0) {
            index = input.findOperatorOnTopLevel("<=>")
            
            if (index < 0) {
                return defaultReturnValue
            } else {
                return index
            }
        } else {
            return index
        }
    }
    
    parseAccessorValue() =>
        accessorValue.class.isOfType(PlaceholderValue) ?
            (accessorValue = Value.parse((PlaceholderValue)accessorValue)) != null :
            true
    
    parseInitializationValue() =>
        initializationValue.class.isOfType(PlaceholderValue) ?
            (initializationValue = Value.parse((PlaceholderValue)initializationValue)) != null :
            true
    
    public parsePlaceholders() =>
        parseAccessorValue() &
        parseInitializationValue()
    
    public writeInitializationValue() => initializationValue ? " = #initializationValue.toNova()" : ""
    public writeAccessorValue() =>
        accessorValue ?
            (isTwoWayAccessor ? " <=> " : " => ") + accessorValue.toNova() :
            ""
    
    public writeNova() => super.writeNova() + writeInitializationValue() + writeAccessorValue()
}