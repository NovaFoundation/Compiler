package "spectra/tree/nodes/generics"

import "spectra/InvalidParseException"
import "spectra/util/Location"
import "spectra/tree/nodes/Node"
import "spectra/tree/nodes/Value"
import "spectra/tree/nodes/Type"

import "spectra/util/CompilerStringFunctions"

trait GenericCompatible {
    visible GenericParameter[] genericParameters
    
    public parseGenericParameters(String input, Bool requireWholeString = false) => true {
        var genericIndex = input.indexOf('<')
        
        if (genericIndex >= 0 && (!requireWholeString || genericIndex == 0)) {
            var end = input.findEndingMatch(genericIndex, '<', '>')
            
            if (end > 0 && (!requireWholeString || end == input.count - 1)) {
                var contents = input.substring(genericIndex + 1, end)
                
                var params = contents.splitAtCommas().map({ new GenericParameter((Node)this, ((Node)this).location, _) })
                genericParameters = params
                
                if (genericParameters.any({ !_ })) { // if any generic parameters didnt parse
                    softly throw new InvalidParseException("Failed to parse all generic parameters '#contents'", (Node)this)
                    
                    return false
                } else {
                    return true
                }
            }
        }
        
        genericParameters = new GenericParameter[0]
    }
    
    public writeGenericParameters() =>
        genericParameters.count > 0 ?
            "<" + genericParameters.map({ _.toNova() }).join(", ") + ">" :
            ""
    
    public cloneTo(GenericCompatible other) => other {
        other.genericParameters = genericParameters
    }
}