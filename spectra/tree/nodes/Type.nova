package "spectra/tree/nodes"

import "spectra/SyntaxMessage"
import "spectra/InvalidParseException"
import "spectra/tree/nodes/Node"
import "spectra/util/Location"
import "spectra/tree/nodes/generics/GenericType"
import "spectra/tree/nodes/generics/GenericArgument"
import "spectra/tree/nodes/generics/GenericParameter"

import "spectra/util/CompilerStringFunctions"

[AutoFinal]
class Type {
    visible Bool isGeneric => false
    visible Bool isPrimitiveType => PRIMITIVE_TYPES.any({ _.equals(name) })
    
    visible static String[] PRIMITIVE_TYPES = ["Bool", "Byte", "Short", "Int", "Long", "Float", "Double", "Char"]
    
    visible var Int arrayDimensions = 0
    
    visible var GenericArgument[] genericArguments = new GenericArgument[0]
    
    public construct(public var String name = null) {}
    
    public static parse(String input, Node parent = null, Location location = Location.INVALID, Bool require = true) -> Type => null {
        var node = new Type(input)
        
        if (!node.parseGenericArguments(input, parent, location)) {
            softly throw new InvalidParseException("Unable to parse generic arguments for type '#input'", parent)
        } else if (!node.parseArray(parent, require)) {
            softly throw new InvalidParseException("Unable to parse array dimensions for type '#input'", parent)
        } else if (!node.name.isIdentifier) {
            softly throw new InvalidParseException("Invalid type '#input'", parent)
        } else {
            if (parent) {
                var param = node.getGenericParameter(parent)
                
                if (param) {
                    node = new GenericType(node, param)
                }
            }
            
            return node
        }
    }
    
    getGenericParameter(Node parent) -> GenericParameter => null {
        if (parent.parentFunction) {
            let param = parent.parentFunction.genericParameters.firstWhere({ _.type.name.equals(name) })
            
            if (param) {
                return param
            }
        }
        if (parent.parentClass) {
            let param = parent.parentClass.genericParameters.firstWhere({ _.type.name.equals(name) })
            
            if (param) {
                return param
            }
        }
    }
    
    parseGenericArguments(String input, Node parent, Location location) => true {
        let genericIndex = input.indexOf('<')
        
        if (genericIndex > 0) {
            name = input.substring(end: genericIndex)
            
            let end = input.findEndingMatch(genericIndex, '<', '>')
            
            if (end > 0) {
                genericArguments = input.substring(genericIndex + 1, end).splitAtCommas().map({ new GenericArgument(parent, location, _) })
                
                if (genericArguments.any({ !_ })) { // if any generic arguments didnt parse
                    return false
                }
            }
        }
    }
    
    parseArray(Node parent, Bool require) => true {
        var start = name.indexOf('[')
        
        if (start > 0) {
            let first = start
            var end = name.findEndingMatch(start, '[', ']')
            var last = end
            
            while (end > start) {
                last = end
                
                arrayDimensions++
                
                if (name.substring(start + 1, end).trim().count > 0) {
                    SyntaxMessage.errorIf("Type declaration '#name' cannot have contents within the array brackets", parent, condition: require)
                    
                    return false
                }
                
                start = name.indexOf('[', end + 1)
                
                if (start < 0) break
                
                end = name.findEndingMatch(start, '[', ']')
            }
            
            if (last > first) {
                name = (name.substring(0, first) + name.substring(last + 1)).trim()
            }
        }
    }
    
    public isValid(Node parent) =>
        isPrimitiveType ||
        parent.parentFile.imports.any({ _.className.equals(name) })
    
    public writeArray() =>
        "[]".repeat(arrayDimensions)
    
    public writeGenericParameters() =>
        genericArguments.count > 0 ?
            "<#{genericArguments.join(", ")}>" :
            ""
    
    public toString() => writeNova()
    public toNova() => writeNova()
    public writeNova() => "#name" + writeArray() + writeGenericParameters()
    
    public cloneTo(Type other) => other {
        other.name = name
        other.arrayDimensions = arrayDimensions
        other.genericArguments = genericArguments
    }
}