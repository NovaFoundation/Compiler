package "compiler"

import "nova/io/File"
import "nova/datastruct/list/Stack"
import "nova/datastruct/list/List"

import "compiler/util/OS"
import "compiler/util/FileUtils"

import "compiler/tree/nodes/ClassDeclaration"
import "compiler/tree/nodes/NovaFile"
import "compiler/tree/nodes/Node"
import "compiler/tree/nodes/Program"
import "compiler/tree/StatementIterator"

import "compiler/util/CompilerStringFunctions"

class Compiler {
    visible static Bool DEBUG = true
    
    visible static Bool testClasses = true
    
    visible String[] errors   = new String[]
    visible String[] warnings = new String[]
    visible String[] info     = new String[]
    
    visible Byte phase
    
    Stack<Node> parents
    
    Program program
    
    NovaFile[] files
    
    public static main(String[] args) {
        var c = new Compiler()
        
        c.compile(null)
        
        Console.waitForEnter()
    }
    
    public construct() {
        
    }
    
    public compile(String[] args) {
        String directory = FileUtils.getWorkingDirectoryPath() + "/"
        
        if (DEBUG) {
            testClasses()
            
            var target = "c"
            
            args = [
                "../Compiler",
				"../Misc/example",
				"../Misc/stabilitytest", 
				"-output-directory", "../NovaCompilerOutput/#target",
				"-package-output-directory", "nova", "../StandardLibrary/#target",
//				"-dir", formatPath(directory + "../example"),
//				"-dir", formatPath(directory + "../stabilitytest"),
//				"-run",
//				"-csource",
				"-formatc",
				//testClasses ? "-v" : "",
				"-v",
//				"-gcc",
//				"-tcc",
//				"-small",
//				"-cargs",
//				"-keepc",
				"-single-thread",
				"-single-file",
				"-main",
//				"example/Lab",
//				"stabilitytest/StabilityTest",
//				"example/SvgChart",
//				"example/HashMapDemo",
//				"example/HashSetDemo",
				"compiler/Compiler",
//				"-nogc",
//				"-no-c-output",
//				"-dry",
//				"-no-notes",
//				"-no-warnings",
//				"-no-errors",
				"-no-optimize",
				"-target", target,
//				"-library",
            ]
            
            program = new Program(this)
            parents = new Stack()
            
            var parentDir = new File("../../../tempstd")
            
            files = parentDir.listFiles(parentDir.location).map({ new NovaFile(new File(parentDir.location + "/" + _)) })
            
            try {
                phase = 1
                
                files.forEach(file -> {
                    program.addChild(file)
                    file.parent = program
                })
                
                formTree(files)
                
                phase++
                
                validateTypes(files)
                
                phase++
                
                parseStatements(files)
                
                var separator = "=============================================================="
                var a = files.map({ "\n#{_.toNova()}\n#separator" }).join("")
                Console.writeLine("#separator" + a)
            } catch (SyntaxErrorException e) {
                
            }
            
            errors.forEach({ Console.writeLine("Error: #_") })
            warnings.forEach({ Console.writeLine("Warning: #_") })
            info.forEach({ Console.writeLine("Info: #_") })
            
            //Console.writeLine("Args: #args")
        }
    }
    
    testClasses() {
        
    }
    
    formTree(NovaFile[] files) {
        files.forEach((file, i) -> {
            var statements = file.source.statements
            
            parents.push(file)
            
            for (statement in statements) {
                Console.writeLine("'#statement'")
                
                var node = parents.peek().parseStatement(statement, require: false)
                
                Console.writeLine("\tbeginsScope: '#statements.beginsScope'\n
                                   \tendsScope: '#statements.endsScope'\n
                                   \tparse: '#node'\n")
                
                if (node != null) {
                    parents.peek().addChild(node)
                }
                
                if (statements.beginsScope) { // TODO: if null, then create something to replace it
                    if (node == null) {
                        SyntaxMessage.error("Unable to parse scope declaration '#statement'", parents.peek(), throwException: false)
                    } else {
                        parents.push(node)
                    }
                }
                if (statements.endsScope) {
                    repeat (statements.scopesEnded) {
                        if (!parents.isEmpty) {
                            parents.pop()
                        }
                    }
                }
            }
            
            if (parents.peek() != file) {
                SyntaxMessage.error("Missing ending brace", file, throwException: false)
            }
        })
    }
    
    validateTypes(NovaFile[] files) {
        files.forEach(file -> {
            if (!file.classes.all({ _.validateTypes() }, false)) {
                Console.writeLine("invalid types")
            }
        })
    }
    
    parseStatements(NovaFile[] files) {
        files.forEach(file -> {
            if (!file.classes.all({ _.parsePlaceholders() }, false)) {
                Console.writeLine("failed to parse placeholders")
            }
        })
    }
}