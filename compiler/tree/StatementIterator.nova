package "compiler/tree"

import "nova/datastruct/list/NoSuchElementException"
import "nova/datastruct/list/Iterator"
import "nova/regex/Pattern"
import "compiler/util/CompilerStringFunctions"

class StatementIterator implements Iterator<String> {
    static Char[] NON_STATEMENT_CHARS = [ ' ', '\n', '\t', '\r', '}' ]
    
    visible String source
    
    visible Bool beginsScope, endsScope
    
    visible Int scopesEnded
    visible Int position
    
    visible Bool hasNext {
        get {
            if (source.count > position) {
                for (i in position..source.count) {
                    if (!NON_STATEMENT_CHARS.contains(source[i])) {
                        return true
                    }
                }
            }
            
            return false
        }
        
        no set
    }
    
    visible String next {
        get {
            if (hasNext) {
                var prev = position
                
                position = source.nextNonWhitespaceIndex(position)
                position = source.calculateStatementEnd(position)
                position = position < 0 ? source.count : position
                
                var nextChar = source.nextNonWhitespaceChar(position)
                
                beginsScope = position < source.count && nextChar == '{'
                endsScope = position < source.count && nextChar == '}'
                
                var statement = source.substring(prev, position++).trim()
                
                updateScopesEnded()
                
                return statement
            }
            
            throw new NoSuchElementException()

            return null
        }
        
        no set
    }
    
    updateScopesEnded() {
        scopesEnded = 0
        
        if (endsScope) {
            var current = source.nextNonWhitespaceIndex(position - 1)
            
            while (current > 0 && source[current] == '}') {
                scopesEnded++
                
                current = source.nextNonWhitespaceIndex(current + 1)
            }
            
            position = current < 0 ? source.count : current
        }
    }
    
    public construct(String source) {
        this.source = source.trim()
        
        reset()
    }
    
    public reset() => this { position = 0 }
}