package "compiler/tree"

import "nova/datastruct/list/Stack"
import "nova/datastruct/list/List"

import "compiler/SyntaxMessage"
import "compiler/Compiler"
import "compiler/SyntaxErrorException"
import "compiler/tree/nodes/Program"
import "compiler/tree/nodes/Node"
import "compiler/tree/nodes/NovaFile"
import "compiler/tree/nodes/ClassDeclaration"
import "compiler/tree/nodes/annotations/Annotation"

import "compiler/util/CompilerStringFunctions"

class SyntaxTree {
    visible Program root
    
    visible Byte phase
    
    Stack<Annotation> pendingAnnotations
    Stack<Node> parents
    
    visible Compiler compiler
    
    public construct(Compiler compiler, Program root) {
        pendingAnnotations = new Stack()
        parents = new Stack()
        
        phase = 1
        
        this.compiler = compiler
        this.root = root
        
        root.tree = this
    }
    
    public formTree() {
        root.files.forEach((file, i) -> {
            var statements = file.source.statements
            
            parents.push(file)
            
            for (statement in statements) {
                if (parents.isEmpty) break
                    
                var full = statement
                
                Node node = null
                
                var annotations = searchAnnotations(statement)
                
                annotations.addTo(pendingAnnotations)
                
                statement = annotations.remainingStatement
                
                if (statement.count > 0) {
                    try {
                        node = parents.peek().parseStatement(statement, require: false)
                    } catch (SyntaxErrorException e) {
                        Console.log(e)
                    }
                    
                    if (node == null) {
                        Console.writeLine("'#full'")
                        Console.writeLine("\tbeginsScope: '#statements.beginsScope'\n
                                           \tendsScope: '#statements.endsScope'\n
                                           \tparse: '#node'\n")
                    }
                    
                    if (node != null) {
                        while (!pendingAnnotations.isEmpty) {
                            node.addAnnotation(pendingAnnotations.pop())
                            
                            // Console.writeLine("Added annotation '#node.annotations.last'")
                            
                            // if (pendingAnnotations.isEmpty) {
                            //     Console.writeLine()
                            // }
                        }
                        
                        parents.peek().addChild(node)
                    }
                } else {
                    // Console.writeLine("Only parsed annotation\n")
                }
                
                if (statements.beginsScope) { // TODO: if null, then create something to replace it
                    if (node == null) {
                        SyntaxMessage.error("Unable to parse scope declaration '#statement'", parents.peek() ?: root, throwException: false)
                        
                        node = parents.peek().generateTemporaryScopeNode()
                    }
                    
                    parents.push(node)
                }
                if (statements.endsScope) {
                    repeat (statements.scopesEnded) {
                        if (!parents.isEmpty) {
                            parents.pop()
                        }
                    }
                }
            }
            
            if (parents.peek() != file) {
                SyntaxMessage.error("Missing ending brace", file, throwException: false)
            }
        })
        
        phase = 2
    }
    
    public validateTypes() {
        root.files.forEach(file -> {
            if (!file.classes.all({ _.validateTypes() }, false)) {
                Console.writeLine("invalid types")
            }
        })
        
        phase = 3
    }
    
    public parseStatements() {
        root.files.forEach(file -> {
            if (!file.classes.all({ _.parsePlaceholders() }, false)) {
                Console.writeLine("failed to parse placeholders")
            }
        })
        
        phase = 4
    }
    
    public static searchAnnotations(String statement) -> AnnotationSearchResult {
        var result = new AnnotationSearchResult(statement)
        var annotation = Annotation.parse(statement, require: false)
        
        while (annotation != null && statement.count > 0) {
            statement = annotation.getRemainingStatement(statement)
            result.annotations.add(annotation)
            result.remainingStatement = statement
            
            // Console.writeLine("Parsed Annotation #annotation")
            
            if (statement.count > 0) annotation = Annotation.parse(statement)
        }
        
        return result
    }
}