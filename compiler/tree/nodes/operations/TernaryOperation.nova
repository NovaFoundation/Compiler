package "compiler/tree/nodes/operations"

import "compiler/SyntaxErrorException"
import "compiler/InvalidParseException"
import "compiler/tree/nodes/Node"
import "compiler/tree/nodes/Value"
import "compiler/tree/nodes/Accessible"
import "compiler/util/Location"

import "compiler/util/CompilerStringFunctions"

/// @Value extension that represents 
///
/// author: Braden Steffaniak
/// since: 
/// version: 
class TernaryOperation extends Value {
    visible Value condition
    visible Value trueValue
    visible Value falseValue
    
    /// Create a new TernaryOperation node.
    /// 
    /// #exampleInputs
    /// 
    /// parent:   The parent of the TernaryOperation node.
    /// location: The location of the input text in the source file.
    public construct(Node parent = null, Location location = Location.INVALID) {
        super(parent, location)
    }
    
    /// Parse the given input into a TernaryOperation node. If the input cannot be parsed
    /// into a TernaryOperation node, null is returned.
    /// 
    /// #exampleInputs:
    ///     Example inputs:
    ///      * 
    ///      * 
    ///      * 
    /// 
    /// input:    The input string to parse into a TernaryOperation instance.
    /// parent:   The parent of the TernaryOperation node.
    /// location: The location of the input text in the source file.
    /// require:  Whether or not to throw a syntax error if the input could not
    ///           be parsed.
    /// return:   The parsed TernaryOperation node, if successful; null otherwise.
    public static parse(String input, Node parent = null, Location location = Location.INVALID, Bool require = true) -> TernaryOperation {
        var questionIndex = input.findOperatorInBaseScope('?')
        
        if (questionIndex > 0) {
            var colonIndex = input.findOperatorInBaseScope(':', start: questionIndex + 2)
            
            if (colonIndex > 0) {
                var node = new TernaryOperation(parent, location)
                
                var condition = input.substring(end: questionIndex).trim()
                var trueValue = input.substring(questionIndex + 1, colonIndex).trim()
                var falseValue = input.substring(colonIndex + 1).trim()
                
                if (!node.parseCondition(condition)) {
                    softly throw InvalidParseException("Could not parse ternary condition '#condition'", node)
                } else if (!node.parseTrueValue(trueValue)) {
                    softly throw InvalidParseException("Could not parse ternary true value '#trueValue'", node)
                } else if (!node.parseFalseValue(falseValue)) {
                    softly throw InvalidParseException("Could not parse ternary false value '#falseValue'", node)
                } else if (!node.parseType()) {
                    softly throw InvalidParseException("Could not parse type for ternary operation '#input'", node)
                } else {
                    return node
                }
            }
        }
        
        return null
    }
    
    parseCondition(String input) =>
        (condition = Value.parse(input, this)) != null
    
    parseTrueValue(String input) =>
        (trueValue = Value.parse(input, this)) != null
    
    parseFalseValue(String input) =>
        (falseValue = Value.parse(input, this)) != null
    
    parseType() => true {
        type = trueValue.type
    }
    
    public toNova() =>
        "#condition.toNova() ? #trueValue.toNova() : #falseValue.toNova()"
}