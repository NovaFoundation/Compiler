package "compiler/tree/nodes"

import "compiler/SyntaxMessage"
import "compiler/util/Location"
import "compiler/tree/nodes/arrays/ArrayAccess"
import "compiler/tree/nodes/operations/Operation"
import "compiler/tree/nodes/variables/Variable"

import "compiler/util/CompilerStringFunctions"

class Value extends Node {
    visible static Byte VALUE = 1, POINTER = 2, REFERENCE = 3, DOUBLE_POINTER = 4
    
    public ArrayAccess arrayAccess
    
    public Type type
    
    public Bool isAssignable => true
    
    public ClassDeclaration typeClass {
        get {
            var imp = parentFile.imports.firstWhere({ _.className.equals(type.name) })
            
            if (imp != null) {
                return imp.classDeclaration
            } else {
                return null
            }
        }
        
        no set
    }
    
    visible static String[] PRIMITIVE_TYPES = ["Bool", "Byte", "Short", "Int", "Long", "Float", "Double", "Char"]
    
    visible Bool isPrimitiveType => PRIMITIVE_TYPES.any({ _.equals(type.name) })
    
    /// <summary>
    /// Create a new Value node.<br><br>
    /// <include id="example-inputs">
    /// </summary>
    /// 
    /// <param name="parent">The parent of the Value node.</param>
    /// <param name="location">The location of the input text in the source file.</param>
    public construct(Node parent = null, Location location = Location.INVALID) {
        super(parent, location)
    }
    
    /// <summary>
    /// Decode the given input into a Value node. If the input cannot be parsed
    /// into a Value node, null is returned.<br><br>
    /// <div id="example-inputs">
    ///     Example inputs:
    ///     <ul>
    ///         <li></li>
    ///         <li></li>
    ///         <li></li>
    ///     </ul>
    /// </div>
    /// </summary>
    /// 
    /// <param name="input">The input string to decode into a Value instance.</param>
    /// <param name="parent">The parent of the Value node.</param>
    /// <param name="location">The location of the input text in the source file.</param>
    /// <param name="require">Whether or not to throw a syntax error if the input could not
    ///     be parsed.</param>
    /// <returns>The parsed Value node, if successful; null otherwise.</returns>
    public static parse(String input, Node parent = null, Location location = Location.INVALID, Bool require = true) -> Value {
        if (input.isIdentifier) {
            var declaration = parent.findVariableDeclaration(input)
            
            if (declaration != null) {
                return new Variable(parent, location, declaration)
            }
        }
        
        var node = null
        
        until (node != null) {
            node = Literal.parse(input, parent, location, require)
            node = Operation.parse(input, parent, location, require)
        }
        
        return node
    }
    
    public static parse(PlaceholderValue placeholder, Bool require = true) =>
        parse(placeholder.value, placeholder.parent, placeholder.location, require)
    
    public parseType(String input) -> Bool {
        if (input != null && input.isIdentifier) {
            type = Type.parse(input)
            
            return type != null
        }
        
        return false
    }
    
    public validateTypes() -> Bool {
        if (type != null && !isPrimitiveType && !parentFile.imports.any({ _.className.equals(type.name) })) {
            invalidTypeError(throwException: false)
            
            return false
        } else {
            return true
        }
    }
    
    public invalidTypeError(Type type = this.type, Bool throwException = true) =>
        SyntaxMessage.error("Invalid type '#type'", this, throwException: throwException)
    
    public writeType() => "#type.toNova()"
    
    public cloneTo(Value other) => other {
        super.cloneTo(other)
        
        other.arrayAccess = arrayAccess
        other.type = type
    }
}