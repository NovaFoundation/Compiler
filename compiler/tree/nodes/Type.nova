package "compiler/tree/nodes"

import "compiler/tree/nodes/Node"
import "compiler/util/Location"
import "compiler/tree/nodes/generics/GenericArgument"

import "compiler/util/CompilerStringFunctions"

class Type {
    public String name
    
    visible GenericArgument[] genericArguments = new GenericArgument[0]
    
    public construct(String name = null) {
        this.name = name
    }
    
    public static parse(String input, Node parent = null, Location location = Location.INVALID, Bool require = true) -> Type {
        var node = new Type()
        
        node.name = input
        
        var genericIndex = input.indexOf('<')
        
        if (genericIndex > 0) {
            node.name = input.substring(end: genericIndex)
            
            var end = input.findEndingMatch(genericIndex, '<', '>')
            
            if (end > 0) {
                node.genericArguments = input.substring(genericIndex + 1, end).splitAtCommas().map({ new GenericArgument(parent, location, _) })
                
                if (node.genericArguments.any({ _ == null })) { // if any generic arguments didnt parse
                    return null
                }
            }
        }
        
        if (node.name.isIdentifier) {
            return node
        } else {
            return null
        }
    }
    
    public toString() => toNova()
    public toNova() => "#name" + (genericArguments.count > 0 ? "<#{genericArguments.join(", ")}>" : "")
}