package "compiler/tree/nodes"

import "compiler/util/Location"
import "compiler/SyntaxMessage"
import "compiler/tree/nodes/closures/ClosureContext"
import "compiler/tree/nodes/closures/ClosureDeclaration"
import "nova/io/File"

class NovaFile extends Node {
    visible NovaFile parentFile => this
    
    visible String name
    
    visible File file
    
    visible ImportList importList
    
    visible Package packageDeclaration
    visible Import[] imports => importList.imports
    
    visible ClosureDeclaration[] closures = new ClosureDeclaration[]
    visible ClosureContext[] contexts = new ClosureContext[]
    
    public ClassDeclaration[] classes
    
    visible static String[] DEFAULT_IMPORTS = [
        "nova/exception/ExceptionData",
        "nova/exception/Exception",
        "nova/exception/DivideByZeroException",
        "nova/io/Console",
        "nova/primitive/number/Number",
        "nova/primitive/number/Byte",
        "nova/primitive/number/Short",
        "nova/primitive/number/Int",
        "nova/primitive/number/Long",
        "nova/primitive/number/Float",
        "nova/primitive/number/Double",
        "nova/primitive/Null",
        "nova/primitive/number/Char",
        "nova/primitive/Bool",
        "nova/datastruct/list/Array",
        "nova/datastruct/list/IntArray",
        "nova/datastruct/list/CharArray",
        "nova/datastruct/list/DoubleArray",
        "nova/datastruct/list/IntRange",
        "nova/thread/Thread",
        "nova/thread/async/Async",
        "nova/gc/GC",
        "nova/math/Math",
        "nova/Object",
        "nova/String",
        "nova/System",
        "nova/Class",
    ]
    
    public construct(File file, Node parent = null, Location location = Location.INVALID) {
        super(parent, location)
        
        this.file = file
        
        packageDeclaration = Package.generateDefaultPackage(this)
        importList = new ImportList(this, location)
        classes = new ClassDeclaration[]
        
        addDefaultImports()
    }
	
    public addChild(Node child) {
        if (child.class.isOfType(ClassDeclaration)) {
            classes.add((ClassDeclaration)child)
        } else if (child.class.isOfType(Import)) {
            imports.add((Import)child)
        } else {
            SyntaxMessage.error("Statement '#child' used in wrong context", child)
        }
    }
    
    public parseStatement(String input, Node parent = null, Location location = Location.INVALID, Bool require = true) -> Node {
    	var node = null
        
        until (node != null) {
            node = ClassDeclaration.parse(input, this, location, require)
            node = Import.parse(input, this, location, require)
        }
        
        return node
    }
    
    addDefaultImports() {
        for (i in DEFAULT_IMPORTS) {
            if (i.count > 0) {
                addImport(i).used = true
            }
        }
    }
    
    public addImport(String location) -> Import {
        if (containsImport(location)) return null
        
        var node = Import.parse("import \"#location\"", this, this.location)
        
        if (node != null) {
            imports.add(node)
        } else {
            SyntaxMessage.error("Invalid import location '#location'", this)
        }
        
        return node
    }
    
    public containsImport(String location, Bool absoluteLocation = true, Bool aliased = false) -> Bool {
        return false
    }
    
    public toNova() =>
        (packageDeclaration.toNova() + "\n\n" +
        imports.filter({ !_.isDefault }).map({ _.toNova() }).join("\n") + "\n" +
        classes.map({ _.toNova() }).join("\n")).trim()
    
    public toString() => "#{name}.nova"
}