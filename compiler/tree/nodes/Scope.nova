package "compiler/tree/nodes"

import "nova/datastruct/Pair"
import "nova/datastruct/list/List"
import "compiler/util/Location"
import "compiler/tree/nodes/operations/Operation"
import "compiler/tree/nodes/operations/Assignment"
import "compiler/tree/nodes/functions/FunctionCall"
import "compiler/tree/nodes/variables/VariableDeclaration"

import "compiler/util/CompilerStringFunctions"

/**
 * Node extension that represents a scope of code. In essence, a
 * collection of statements within a pair of curly braces.<br>
 * <br>
 * For example:
 * <blockquote><pre>
 * {
 *     ...
 * 
 *     // Statements within here...
 * 
 *     ...
 * }</pre></blockquote>
 * 
 * @author    Braden Steffaniak
 * @since    v0.1 Apr 5, 2014 at 10:54:20 PM
 * @version    v0.2.41 Dec 17, 2014 at 7:48:17 PM
 */
class Scope extends NodeList {
    private Int id
    
    visible VariableDeclaration[] declarations
    
    visible Int depth {
        get {
            Node current = this
            
            var depth = 0
            
            while (current != null) {
                depth++
                
                current = current.parentWithScope
            }
            
            return depth
        }
        
        no set
    }
    
    /// <summary>
    /// Create a new Scope node.<br><br>
    /// <include id="example-inputs">
    /// </summary>
    /// 
    /// <param name="parent">The parent of the Scope node.</param>
    /// <param name="location">The location of the input text in the source file.</param>
    public construct(Node parent = null, Location location = Location.INVALID) {
    	super(parent, location)
        
        declarations = new VariableDeclaration[]
    }
    
    public parseStatement(String input, Node parent = null, Location location = Location.INVALID, Bool require = true) -> Node {
        if (phase == 1) {
            return PlaceholderValue.parse(input, parent, location)
        }
        
        Node node = null
        
        until (node != null) {
        	node = parseIdentifierAccess(input, parent, require: require)
            node = Assignment.parse(input, parent, location, require)
            node = Operation.parse(input, parent, location, require)
            node = Value.parse(input, parent, location, require)
        }
        
        return node
    }
    
    public parseAccessible(String input, Node parent = this.parent, Bool require = true) -> Accessible {
    	var node = null
        
        until (node != null) {
            node = StaticClassReference.parse(input, parent, location, require)
            node = FunctionCall.parse(input, parent, location, require)
        }
    	
    	return node
    }
    
    parseIdentifierAccess(String input, Node parent, Bool require = true) -> Node {
    	var prev = 0
    	var dot  = input.findDotOperatorIndex()
    	
    	var fragments = new String[]
    	
    	while (dot > 0) {
    		fragments.add(input.substring(prev, dot))
    		
    		prev = dot + 1
    		dot  = input.findDotOperatorIndex(prev)
    	}
    	
    	if (prev > 0) {
    		fragments.add(input.substring(prev))
    		
    		var root    = parseAccessible(fragments[0], require: require)
    		var current = root
    		
    		if (current != null) {
    			if (fragments.skip(1).all({
    				var accessed = parseAccessible(_, parent: (Node)current, require: require)
    				
    				if (accessed != null) {
    					current.accessedNode = accessed
    					
    					return true
    				}
    				
    				return false
    			})) {
    				return root
    			}
    		}
	    }
    	
    	return null
    }
    
    public parsePlaceholders() =>
        children.all(child -> {
            if (child.class.isOfType(PlaceholderValue)) {
                var placeholder = (PlaceholderValue)child
                
                var parsed = parseStatement(placeholder.value, child.parent, child.location, true)
                
                if (parsed != null) {
                    return children.replace(child, parsed)
                } else {
                    return false
                }
            } else {
                return true
            }
        }, false)
    
    public toNova() =>
        "{\n" + children.map({ _.toNova() + "\n" }).join() + "}"
}