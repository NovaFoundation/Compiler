package "compiler/tree/nodes"

import "nova/datastruct/Pair"
import "nova/datastruct/list/List"

import "compiler/util/Location"
import "compiler/tree/nodes/Accessible"
import "compiler/tree/nodes/operations/Operation"
import "compiler/tree/nodes/operations/Assignment"
import "compiler/tree/nodes/exceptionhandling/Catch"
import "compiler/tree/nodes/exceptionhandling/Throw"
import "compiler/tree/nodes/functions/FunctionCall"
import "compiler/tree/nodes/controlstructures/IfStatement"
import "compiler/tree/nodes/controlstructures/ElseStatement"
import "compiler/tree/nodes/controlstructures/loops/Loop"
import "compiler/tree/nodes/variables/VariableDeclaration"
import "compiler/tree/nodes/variables/LocalDeclaration"

import "compiler/util/CompilerStringFunctions"

/// @NodeList extension that represents a scope of code. In essence, a
/// collection of statements within a pair of curly braces.
/// 
/// #example:
///     For example:
///     <code>
///     {
///         ...
///         
///         // Statements within here...
///         
///         ...
///     }
///     </code>
/// 
/// author:  Braden Steffaniak
/// since:   v0.1 Apr 5, 2014 at 10:54:20 PM
/// version: v0.2.41 Dec 17, 2014 at 7:48:17 PM
class Scope extends NodeList {
    private Int id
    
    visible VariableDeclaration[] declarations
    
    static Class[] LADDER_FORM = [ElseStatement, Catch]
    
    visible Int depth {
        get {
            Node current = this
            
            var depth = 0
            
            while (current != null) {
                depth++
                
                current = current.parentWithScope
            }
            
            return depth
        }
        
        no set
    }
    
    /// Create a new Scope node.
    /// 
    /// #example
    /// 
    /// parent:   The parent of the Scope node.
    /// location: The location of the input text in the source file.
    public construct(Node parent = null, Location location = Location.INVALID) {
    	super(parent, location)
        
        declarations = new VariableDeclaration[]
    }
    
    public parseStatement(String input, Node parent = null, Location location = Location.INVALID, Bool require = true) -> Node {
        if (phase == 1) {
            return PlaceholderValue.parse(input, parent, location)
        }
        
        Node node = null
        
        until (node != null) {
        	node = Accessible.parseDotAccess(input, parent, require: require)
            node = IfStatement.parse(input, parent, location, require)
            node = ElseStatement.parse(input, parent, location, require)
            node = Throw.parse(input, parent, location, require)
            node = Loop.parse(input, parent, location, require)
            node = Return.parse(input, parent, location, require)
            node = LocalDeclaration.parse(input, parent, location, require)
            node = Assignment.parse(input, parent, location, require)
            node = Operation.parse(input, parent, location, require)
            node = Value.parse(input, parent, location, require)
        }
        
        if (node.class.isOfType(LocalDeclaration)) {
            declarations.add((LocalDeclaration)node)
        }
        
        return node
    }
    
    public parsePlaceholders() =>
        children.all(child -> {
            if (child.class.isOfType(PlaceholderValue)) {
                var placeholder = (PlaceholderValue)child
                
                var parsed = parseStatement(placeholder.value, child.parent, child.location, true)
                
                if (parsed != null) {
                    children.replace(child, parsed)
                    
                    if (placeholder.nodes != null) {
                        //parsed.scope = placeholder.scope
                        
                        parsed.parsePlaceholderChildren(placeholder.nodes)
                        
                        /*if (parsed.scope != null) {
                            return parsed.scope.parsePlaceholders()
                        }*/
                    }
                    
                    return parsed.parsePlaceholders()
                    //return true
                } else {
                    return false
                }
            } else {
                return true
            }
        }, false)
    
    printPrecedingWhitespace(Node child) =>
        LADDER_FORM.contains(child.class) ? " " : "\n"
    
    childToNova(Node child) =>
        printPrecedingWhitespace(child) + child.toNova()
    
    public writeNova() =>
        "{" + children.map(childToNova).join() + "\n}"
}