package "compiler/tree/nodes"

import "compiler/Compiler"
import "compiler/InvalidParseException"
import "compiler/error/UnimplementedOperationException"
import "compiler/tree/nodes/annotations/Annotatable"
import "compiler/tree/nodes/annotations/Annotation"
import "compiler/tree/nodes/exceptionhandling/Try"
import "compiler/util/Location"
import "compiler/error/UnimplementedOperationException"
import "compiler/tree/nodes/functions/FunctionDeclaration"
import "compiler/tree/nodes/variables/VariableDeclaration"

import "nova/datastruct/Bounds"

/// Class that is the parent of all Nodes on the Tree. Keeps the basic
/// information of where the statement was in the source, and where it was
/// output in the destination file.
/// 
/// author:  Braden Steffaniak
/// since:   v0.1 Jan 5, 2014 at 9:00:11 PM
/// version: v0.2.41 Dec 17, 2014 at 7:48:17 PM
class Node implements Annotatable {
    [*] Location location
    
    [*] Annotation[] annotations
    
    [+] Node parent
    
    [*] String locationInfo {
        get {
            String info = ""
            
            if (parentFile != null) {
                info += "in file #parentFile.name"
            }
            if (location != null) {
                info += (info.count > 0 ? " " : "") + "on line number #location.lineNumber at offset #location.offset"
            }
            
            return info
        }
        
        no set
    }
    
    [+] String nodeType {
        get {
            var name = this.class.name
            
            return name
        }
        
        no set
    }
    
    
    /// Get whether or not the specified Node is being decoded at
    /// the current moment.
    /// 
    /// return: Whether or not the specified Node is being decoded at
    ///         the current moment.
    [*] Bool isDecoding => false
    [*] Bool isValid => parent != null
    [*] Bool isUserMade => true
    [*] Bool isWithinStaticContext => parentFunction == null || !parentFunction.isInstance
    [*] Bool isWithinExternalContext => parent?.isWithinExternalContext
    
    [*] Program program => parent?.program
    
    [*] Byte phase => program.tree.phase
    
    [*] NovaFile parentFile => parent?.parentFile
    [*] Bool isWithinFile => parentFile != null
    
    [*] FunctionDeclaration parentFunction => parent?.parentFunction
    [*] Bool isWithinFunction => parentFunction != null
    
    [*] Try parentTry => parent?.parentTry
    [*] Bool isWithinTry => parentTry != null
    
    [*] ClassDeclaration parentClass => parent?.parentClass
    [*] Bool isWithinClass => parentClass != null
    
    [*] Scope parentScope => parentWithScope.scope
    [*] Bool isWithinScope => parentScope != null
    
    [*] Node parentWithScope {
        get {
            if (parent == null) return null
            
            return parent.containsScope ? parent : parent.parentWithScope
        }
        
        no set
    }
    
    [+] Scope scope => null {
        set {}
    }
    
    [*] Bool containsScope => scope != null
    
    [*] Node next => getAdjacentNode(1)
    [*] Node previous => getAdjacentNode(-1)
    
    [*] Int index {
    	get { parentScope.children.indexOf(this) }
        set { parentScope.children.swap(index, value) }
    }
    
    [+] getAdjacentNode(Int offset) -> Node {
        if (parent != null) {
            Int index = this.index + offset
            
            if (index >= 0 && index < parentScope.children.count) {
                return parentScope.children[index]
            }
        }
        
        return null
    }
    
    /// Create a new Node. Initializes the data.
    /// 
    /// parent:   The Node to act as the parent temporarily.
    /// location: The location of the Node in the source file.
    [+] construct(Node parent = null, Location location = Location.INVALID) {
        this.parent = parent
        this.location = location
    }
    
    [Override]
    [+] addAnnotation(Annotation annotation) {
        annotations = annotations ?: new Annotation[]
        
        annotations.add(annotation)
        
        annotation.parent = this
    }
    
    /// Detach the specified node from its parent.
    [+] detach() {
        if (isDecoding) return
        
        detach(parent)
    }
    
    /// Detach the specified Node from the given Node.
    ///
    /// fromNode: The Node to detach the specified Node from.
    private detach(Node fromNode) {
    	var p = parent
    	
        parent = null
        
        p.onChildDetached(this)
        onRemoved(fromNode)
    }
    
    [+] onAdded(Node parent) {}
    [+] onRemoved(Node from) {}
    
    [+] onAfterDecoded() => true
    [+] onNextStatementDecoded(Node next) => true
    [+] onStackPopped() {}
    [+] followedByScope(Bool scope) {}
    [+] onChildReplaced(Node old, Node replacement) {}
    [+] onReplaced(Node parent, Node replacement) {}
    [+] onChildDetached(Node child) {}
    
    [+] addChild(Node child) {
        child.parent = this
    }
    
    /// Validate the node to make last minute changes or error checking.
    /// 
    /// phase:  The phase that the node is being validated in.
    /// return: The Node to continue the validation off of.
    [+] validate(Int phase) -> ValidationResult {
        return annotations?.reverse().firstNonNull({
            ValidationResult result = _.validate(phase)
            
            return result.skipValidation ? result : null
        }) ?: new ValidationResult(this)
        
        /*return annotations?.reverse()
            .firstNonNull({ (var result = _.validate(phase)).skipValidation ? result : null }) ?:
            new ValidationResult(this)*/
    }
    
    [+] findVariableDeclaration(String name, Bool searchAncestors = true) -> VariableDeclaration {
        if (containsScope) {
            var declaration = scope.declarations.firstWhere({ _.name.equals(name) })
            
            if (declaration != null) {
                return declaration
            }
        }
        
        if (searchAncestors && parent != null) {
            return parent.findVariableDeclaration(name, searchAncestors)
        }
        
        return null
    }
    
    [+] parseStatement(String input, Node parent = null, Location location = Location.INVALID, Bool require = true) -> Node {
        return parentWithScope?.parseStatement(input, parent, location, require)
    }
    
    [+] generateTemporaryScopeNode() -> Node =>
        throw new UnimplementedOperationException("#this.class does not implement generateTemporaryScopeNode")
    
    [+] [Static] strictParse(action()) {
        try {
            action()
        } catch all (InvalidParseException e) {
            Console.log(e)
        }
    }
    
    /// Return a new Node containing a copy of the values of the
    /// specified node, including clones of the children.
    /// 
    /// parent:        The Node to set as the parent.
    /// location:      The Location instance holding the information.
    /// cloneChildren: Whether or not to clone the children of the
    ///                Node as well.
    /// return:        A clone of the specified Node.
    [+] clone(Node parent = null, Location location = Location.INVALID, Bool cloneChildren = true) =>
        cloneTo(new Node(parent, location))
    
    [+] cloneTo(Node other) => other {
        other.parent = parent
        other.location = location
        other.annotations = annotations
    }
    
    [+] replace(Node toReplace, Node replacement) => false
    [+] validateTypes() => true
    [+] parsePlaceholders() => true
    
    [+] writeAnnotationSeparator() => " "
    
    [+] writeAnnotations() =>
        annotations != null && annotations.count > 0 ?
            annotations.map({ _.toNova() }).join(" ") + writeAnnotationSeparator() :
            ""
    
    [+] toNova() -> String => writeAnnotations() + writeNova()
    
    [+] writeNova() => "{{#this.class}}"
    [+] toString() => toNova()
}