package "compiler/tree/nodes/functions"

import "compiler/SyntaxErrorException"
import "compiler/InvalidParseException"
import "compiler/util/Location"
import "compiler/tree/nodes/Node"
import "compiler/tree/nodes/Value"
import "compiler/tree/nodes/Type"
import "compiler/tree/nodes/variables/VariableDeclaration"

import "compiler/util/CompilerStringFunctions"

/// @Instantiation extension that represents 
///
/// author: Braden Steffaniak
/// since: 
/// version: 
class ArrayInstantiation extends Instantiation {
    visible Value[] dimensions = new Value[]
    
    /// Create a new ArrayInstantiation node.
    /// 
    /// #exampleInputs
    /// 
    /// parent:   The parent of the ArrayInstantiation node.
    /// location: The location of the input text in the source file.
    public construct(Node parent = null, Location location = Location.INVALID) {
        super(parent, location)
    }
    
    /// Parse the given input into a ArrayInstantiation node. If the input cannot be parsed
    /// into a ArrayInstantiation node, null is returned.
    /// 
    /// #exampleInputs:
    ///     Example inputs:
    ///      * 
    ///      * 
    ///      * 
    /// 
    /// input:    The input string to parse into a ArrayInstantiation instance.
    /// parent:   The parent of the ArrayInstantiation node.
    /// location: The location of the input text in the source file.
    /// require:  Whether or not to throw a syntax error if the input could not
    ///           be parsed.
    /// return:   The parsed ArrayInstantiation node, if successful; null otherwise.
    public static parse(String input, Node parent = null, Location location = Location.INVALID, Bool require = true) -> ArrayInstantiation {
        if (input.nextWord().equals("new")) {
            var node = new ArrayInstantiation(parent, location)
            
            var arrayString = input.substring("new".count + 1).trim()
            var arrayData = arrayString.getArrayAccesses()
            
            if (arrayData.item1 != null) {
                var type = arrayString.substring(end: arrayData.item2[0]).trim()
                
                if (!node.parseType(type)) {
                    softly throw new InvalidParseException("Unable to parse array type '#type'", node)
                } else if (!node.parseDimensions(arrayData.item1)) {
                    softly throw new InvalidParseException("Unable to parse array dimensions '#arrayString.substring(arrayData.item2[0]).trim()'")
                } else {
                    node.declaration = new VariableDeclaration(parent, location)
                    node.declaration.name = type
                    node.declaration.type = new Type(type)
                    
                    return node
                }
            }
        }
        
        return null
    }
    
    parseDimension(String dimension) => true {
        var value = Value.parse(dimension, this)
        
        if (value != null) {
            dimensions.add(value)
        } else {
            return false
        }
    }
    
    parseDimensions(String[] dimensions) =>
        dimensions.all(parseDimension, false)
    
    public writeDimensions() =>
        dimensions.map({ "[#{_.toNova()}]" }).join()
    
    public writeNova() => "new #writeType()" + writeDimensions()
}