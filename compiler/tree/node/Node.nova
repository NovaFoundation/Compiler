package "compiler/tree/node"

import "compiler/Compiler"
//import "compiler/TestContext"
//import "compiler/ValidationResult"
import "compiler/error/UnimplementedOperationException"
import "compiler/tree/node/annotation/Annotatable"
import "compiler/tree/node/annotation/Annotation"
import "compiler/tree/node/exceptionhandling/Try"
import "compiler/util/Location"
import "compiler/util/StringUtils"

import "nova/datastruct/Bounds"

/**
 * Class that is the parent of all Nodes on the Tree. Keeps the basic
 * information of where the statement was in the source, and where it was
 * output in the destination file. A Node can have any number of
 * children, however some of the extensions of Node have default
 * children at the start.
 * 
 * @author	Braden Steffaniak
 * @since	v0.1 Jan 5, 2014 at 9:00:11 PM
 * @version	v0.2.41 Dec 17, 2014 at 7:48:17 PM
 */
public abstract class Node implements Listenable, Annotatable
{
	private Location		locationIn
	
	private Node			parent

	private Node[]			children
	private Annotation[]	annotations
	
	/**
	 * Get the Scope instance of this Node if it even has
	 * a scope. If the Node does not have a Scope then this
	 * method call will return null.
	 * 
	 * @return The Scope instance, if it exists.
	 */
	public getScope() -> Scope
	{
		return null
	}
	
	/**
	 * Get whether or not the current node type has a scope.
	 * 
	 * @return Whether or not the current node type has a scope.
	 */
	public containsScope() -> Bool
	{
		return getScope() != null;
	}
	
	[Override]
	public addAnnotation(Annotation annotation)
	{
		if (annotations == null)
		{
			annotations = new Array()
		}
		
		annotations.add(annotation)
		
		annotation.setTemporaryParent(this)
	}
	
	/**
	 * Set a temporary parent for the specified Node. When, if ever,
	 * the Node is formally added to a Node, the temporary parent
	 * will be removed.
	 * 
	 * @param parent The Node to act as the parent temporarily.
	 */
	public setTemporaryParent(Node parent)
	{
		if (this.parent != parent)
		{
			detach()
			
			this.parent = parent
		}
	}
	
	/**
	 * Get whether or not the specified Node is being decoded at
	 * the current moment.
	 * 
	 * @return Whether or not the specified Node is being decoded at
	 * 		the current moment.
	 */
	public isDecoding() -> Bool
	{
		return parent == null || !parent.containsChild(this);
	}
	
	/**
	 * Detach the specified node from its parent.
	 */
	public detach()
	{
		if (parent == null || isDecoding())
		{
			return
		}
		
		Node from = parent
		
		if (parent.children.count > 0 && !parent.containsChild(this) && parent.containsScope())
		{
			from = parent.getScope()
		}
		
		detach(from)
	}
	
	/**
	 * Detach the specified Node from the given Node.
	 * 
	 * @param fromNode The Node to detach the specified Node from.
	 */
	private detach(Node fromNode)
	{
		fromNode.children.remove(this)
		
		parent = null
		
		onRemoved(fromNode)
	}
	
	public onRemoved(Node parent)
	{
		
	}
	
	/**
	 * Get whether or not the given Node is a child of the specified
	 * Node.
	 * 
	 * @param child The Node to check whether is a child or not.
	 * @return Whether or not the given Node is a child.
	 */
	public containsChild(Node child) -> Bool
	{
		return containsChild(child, false)
	}
	
	public containsChild(Node child, Bool recursive) -> Bool
	{
		if (children.contains(child))
		{
			return true
		}
		
		if (recursive)
		{
			for (n in children)
			{
				if (n.containsChild(child, recursive))
				{
					return true
				}
			}
		}
		
		return false
	}
	
	public onAdded(Node parent)
	{
		
	}
	
	/**
	 * Return a new Node containing a copy of the values of the
	 * specified node, including clones of the children.
	 * 
	 * @param temporaryParent The Node to act as the parent
	 * 		temporarily.
	 * @param locationIn The Location instance holding the information.
	 * @return A clone of the specified Node.
	 */
	public clone(Node temporaryParent, Location locationIn) -> Node
	{
		return clone(temporaryParent, locationIn, true)
	}
	
	/**
	 * Return a new Node containing a copy of the values of the
	 * specified node, including clones of the children.
	 * 
	 * @param temporaryParent The Node to act as the parent
	 * 		temporarily.
	 * @param locationIn The Location instance holding the information.
	 * @param cloneChildren Whether or not to clone the children of the
	 * 		Node as well.
	 * @return A clone of the specified Node.
	 */
	public abstract clone(Node temporaryParent, Location locationIn, Bool cloneChildren) -> Node
}