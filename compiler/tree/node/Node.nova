package "compiler/tree/node"

import "compiler/Compiler"
import "compiler/error/UnimplementedOperationException"
import "compiler/tree/node/annotation/Annotatable"
import "compiler/tree/node/annotation/Annotation"
import "compiler/tree/node/exceptionhandling/Try"
import "compiler/util/Location"
import "compiler/util/StringUtils"
import "compiler/error/UnimplementedOperationException"

import "nova/datastruct/Bounds"

/**
 * Class that is the parent of all Nodes on the Tree. Keeps the basic
 * information of where the statement was in the source, and where it was
 * output in the destination file. A Node can have any number of
 * children, however some of the extensions of Node have default
 * children at the start.
 * 
 * @author	Braden Steffaniak
 * @since	v0.1 Jan 5, 2014 at 9:00:11 PM
 * @version	v0.2.41 Dec 17, 2014 at 7:48:17 PM
 */
public abstract class Node implements Annotatable
{
	visible Location location
	
	public Node parent
	{
		get { return parent }
		
		set(Node value)
		{
			if (parent != value)
			{
				detach()
				
				parent = value
			}
		}
	}
	
	visible Node[] children
	visible Annotation[] annotations
	
	/**
	 * Get the Scope instance of this Node if it even has
	 * a scope. If the Node does not have a Scope then this
	 * method call will return null.
	 * 
	 * @return The Scope instance, if it exists.
	 */
	public Scope scope
	{
		get { return null }
		set { throw new UnimplementedOperationException("This Node does not support Scopes") }
	}
	
	/**
	 * Get whether or not the specified Node is being decoded at
	 * the current moment.
	 * 
	 * @return Whether or not the specified Node is being decoded at
	 * 		the current moment.
	 */
	visible Bool isDecoding
	{
		get { return parent == null || !parent.containsChild(this) }
		no set
	}
	
	visible Bool containsScope
	{
		get { return scope != null }
		no set
	}
	
	/**
	 * Create a new Node. Initializes the data.
	 * 
	 * @param parent The Node to act as the parent temporarily.
	 * @param location The location of the Node in the source file.
	 */
	public construct(Node parent, Location location)
	{
		children = Array(4)
		
		this.parent = parent
		this.location = location
	}
	
	[Override]
	public addAnnotation(Annotation annotation)
	{
		annotations = annotations ?: new Array()
		
		annotations.add(annotation)
		
		annotation.parent = this
	}
	
	/**
	 * Detach the specified node from its parent.
	 */
	public detach()
	{
		if (isDecoding) return
		
		var from = parent
		
		if (parent.children.count > 0 && !parent.containsChild(this) && parent.containsScope)
		{
			from = parent.scope
		}
		
		detach(from)
	}
	
	/**
	 * Detach the specified Node from the given Node.
	 * 
	 * @param fromNode The Node to detach the specified Node from.
	 */
	private detach(Node fromNode)
	{
		fromNode.children.remove(this)
		
		parent = null
		
		onRemoved(fromNode)
	}
	
	public onRemoved(Node parent)
	{
		
	}
	
	/**
	 * Get whether or not the given Node is a child of the specified
	 * Node.
	 * 
	 * @param child The Node to check whether is a child or not.
	 * @return Whether or not the given Node is a child.
	 */
	public containsChild(Node child, Bool recursive = false) -> Bool
	{
		if (children.contains(child))
		{
			return true
		}
		else if (recursive)
		{
			children.any({ _.containsChild(child, true) })
		}
		
		return false
	}
	
	public onAdded(Node parent)
	{
		
	}
	
	/**
	 * Return a new Node containing a copy of the values of the
	 * specified node, including clones of the children.
	 * 
	 * @param temporaryParent The Node to act as the parent
	 * 		temporarily.
	 * @param locationIn The Location instance holding the information.
	 * @param cloneChildren Whether or not to clone the children of the
	 * 		Node as well.
	 * @return A clone of the specified Node.
	 */
	public abstract clone(Node temporaryParent, Location locationIn, Bool cloneChildren = true) -> Node
}