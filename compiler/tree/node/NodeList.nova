package "compiler/tree/node"

import "compiler/util/Location"

class NodeList<E extends Node> extends Node {
    visible Node[] children
    visible Bool isEmpty => children.count == 0
    
    /// <summary>
    /// Create a new NodeList node.<br><br>
    /// <include id="example-inputs">
    /// </summary>
    /// 
    /// <param name="parent">The parent of the NodeList node.</param>
    /// <param name="location">The location of the input text in the source file.</param>
    public construct(Node parent = null, Location location = Location.INVALID) {
        super(parent, location)
        
        children = Array(4)
    }
    
    //public replaceWith(Node replacement) => parent.replace(this, replacement)
    
    public replace(Node old, Node replacement, Bool detach = true) {
        Int index = children.indexOf(old)
        
        if (detach) {
            old.detach()
        }
        
        if (replacement != null) {
            addChild(replacement, index, detach)
        }
        
        onChildReplaced(old, replacement)
        old.onReplaced(this, replacement)
    }
    
    public addChild(Node node, Int index = children.count, Bool detach = true) -> Node {
        if (detach) {
            // If the node already belongs to a parent, remove it from its old parent.
            node.detach()
            
            // Set this instance as the new parent.
            node.parent = this

            children.add(index, node)
        } else {
            children[index] = node
        }
        
        node.onAdded(this)
        
        return node
    }
    
    /**
     * Get whether or not the given Node is a child of the specified
     * Node.
     * 
     * @param child The Node to check whether is a child or not.
     * @return Whether or not the given Node is a child.
     */
    public containsChild(Node child, Bool recursive = false) =>
            children.contains(child)// || (recursive && children.any({ _.containsChild(child, true) }))
    
    /**
     * Give the specified node the given nodes children. This removes the
     * children from the given oldParent node.
     * 
     * @param oldParent The parent to inherit the children from.
     * @param clone Whether or not to clone the children and not remove
     *         them from the previous owner.
     */
    public inheritChildren(NodeList oldParent, Bool clone = false) =>
        oldParent.children.forEach(child -> {
            addChild(clone ? child.clone(this, child.location, true) : child)
        })
    
    public removeChild(Node node) => removeChild(children.indexOf(node))
    
    public removeChild(Int index) -> Node {
        if (index < 0) return null
        
        Node node = children[index]
        
        node.detach()
        
        return node
    }
    
    public slaughterChildren() => children.forEach(head -> head.detach())
}